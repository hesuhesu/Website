<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLTF/GLB 파일 업로드 및 렌더링</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".gltf,.glb" /><button><a href = "../index.html">돌아가기</a></button>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script>
        // 기본적인 Three.js 씬 설정
        const scene = new THREE.Scene();
        scene.scale.set(0.5, 0.5, 0.5);
        scene.position.set(0, 0, 0);
        
        // 모델의 bounding box 계산
        const box = new THREE.Box3().setFromObject(scene);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(center.x, center.y, size.z * 2); // 모델 크기에 따라 카메라 위치 조정
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: false,
            preserveDrawingBuffer: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff, 1);

        document.getElementById('container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);
  
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);

        // 축 선 그리기
        const axesHelper = new THREE.AxesHelper(50);
          scene.add(axesHelper);

        // 그리드 그리기
        const gridHelper = new THREE.GridHelper(100,100);
        scene.add(gridHelper);

        // OrbitControls 추가
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // DracoLoader 설정
        const dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/draco/'); // Draco 디코더 경로 설정

        // GLTFLoader 인스턴스 생성 및 DracoLoader 설정
        const loader = new THREE.GLTFLoader();
        loader.setDRACOLoader(dracoLoader);

        // 파일 업로드 이벤트 리스너
        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    const blob = new Blob([contents]);
                    const url = URL.createObjectURL(blob);

                    // GLTF 파일 로드
                    loader.load(url, (gltf) => {
                        scene.add(gltf.scene);
                        URL.revokeObjectURL(url); // 메모리 해제
                    }, undefined, (error) => {
                        console.error(error);
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

         // 애니메이션 믹서 추가
         const mixer = new THREE.AnimationMixer(scene);
          gltf.animations.forEach((clip) => {
              mixer.clipAction(clip).play(); // 모든 애니메이션 클립 재생
          });

          // 두 번 클릭 이벤트 추가
          let autoRotate = false; // 자동 회전 상태 변수
          renderer.domElement.addEventListener('dblclick', () => {
            autoRotate = !autoRotate; // 자동 회전 상태 전환
          });
          const clock = new THREE.Clock();

        // 애니메이션 루프
        const animate = function () {
            requestAnimationFrame(animate);
            controls.update(); // clock.getDelta() 안에 추가할려면 추가
            const delta = clock.getDelta(); // 시간 간격 계산
            mixer.update(delta); // 애니메이션 믹서 업데이트
            // 자동 회전 기능
            if (autoRotate) {
              scene.rotation.y += 0.01; // Y축을 기준으로 회전
            }
            renderer.render(scene, camera);
        };
        animate();
    </script>
</body>
</html>